# 01. "模块"、"包"、"库"、"框架"

[toc]

## 1. "模块"、"包"、"库"、"框架"的基础概念

### 模块(module)

* 为了使代码更容易维护，提高代码重用价值，可以将一组相关功能的代码写入一个单独的`.py`文件中，供别人导入使用，这个`.py`文件就被称作是一个模块。
* 模块名：去除.py后缀名后的文件名称，例如sz.py则模块名是sz

### 包(package)

* 包是一个有层次的文件目录结构，它定义了由n个模块或n个子包。

* 包含`__init__.py`文件，这个目录下一定得有这个`__init__.py`文件和其它模块或子包。
* 其实在Python3.3版本往后可以不用创建`__init__.py`文件，但是为了代码版本兼容，以及做一些其他包处理操作，目前还是建议创建。
* `__init__.py`文件的作用：第一次导入这个包的时候，都会自动的执行这个文件。
* 可以创建多层级包，直接在包里面创建另外一个包即可，可以无限级嵌套。
* 包名：就是文件夹名称。
* 包也是有入口的，在包名文件夹下创建一个`__main__.py`文件，那么我们执行`python3 包名`的时候就会自动执行此入口文件。

### 库(lib)

* 参考其他编程语言的一个喊法。
* 是完成一定功能的代码集合。
* 具体表现可以是一个模块，也可以是包。

### 框架

* 一个架构层面的概念。

* 从库功能的角度来看：解决一个开放性问题而设计的具有一定约束性的支撑结构。

* 通过一个框架，可以快速实现一个问题解决的骨架，到时按照框架的角色去填充、交互就可以完成一个质量好，维护性高的项目。
  例如Web框架：Flask、Django



## 2. "标准包/模块"、"三方包/模块"、"自定义包/模块"

### 标准包/模块

* 安装Python后，自动帮我们安装好的一些模块；可以直接导入使用。
* 每个安装Python的用户电脑上都有这些模块
* 在你电脑上写的使用某个系统模块的代码，到其他人电脑上，同样能够运行。
* 满足我们基本的功能需求
* "内建包/模块"：
  * 当我们在编码的过程中，Python自动帮我们导入的模块，`Module builtins`
  * 我们使用这些功能的时候，不需要手动的导入该模块，直接使用就可以
* 由官方发布，使用可靠，几乎没有bug，即使有也有团队立即修复，有健全的使用文档说明

### 三方包/模块

* 有些功能，系统模块没有实现；或者实现了，但我们使用起来比较复杂，就有一些开发者，开发了一些使用更方便的模块，供其他开发者使用，有可能也使用到了系统的某些模块，也有可能没有使用。
* 其他开发者，需要下载安装才可以。
* 如果你的代码使用了某个三方模块，到时候把代码拷贝给别人后，别人也需要先安装同样的三方模块后才能运行。
* 由网友提供，可能文档不健全、更新不及时或者根本不更新、可能有bug
* 安装方式
  * 源码安装：自己手动去某个地方去下载，然后安装到本地
  * 包管理器安装：更加简单的自动化的为用户安装管理包和模块，只需要一个或几个命令就可以完成

### 自定义包/模块

* 我们自己写的一些好用的模块
* 发布出去给别人用，就变成了三方包/模块



## 3. 查看 "包 / 模块" 的存放位置及内容

```python
import os
import flask

print(os.__file__)
print(flask.__file__)
print(dir(os))
print(dir(flask))
```





## 2. "包" 相关

```bash
my_package
├── __main__.py
└── __init__.py
```

### `__main__.py`

* 是一个特殊的可选文件。
* 用于将包作为可执行模块运行时的入口点。
* 该文件可用于定义包级别的命令行接口（Command Line Interface，CLI）或初始化逻辑。

* 包也是有入口的，在包名文件夹下创建一个`__main__.py`文件，那么我们执行`python3 包名`的时候就会自动执行此入口文件。

```bash
my_package
└── __main__.py
```

```python
# __main__.py
print("This is my_package")
```

```bash
$ python my_package
> This is my_package
```



### `__init__.py`

* 是一个特殊的可选文件。
  * 在 Python 3.3 版本往后可以不用创建`__init__.py`文件，但是为了代码版本兼容，以及做一些其它包处理操作，还是建议创建。
  
* 用于指示目录是一个包（package）。

* 当一个包在本程序生命周期内被第一次导入时，Python会查找该包下的`__init__.py`文件，并执行其中的代码。

* 虽然该文件可以为空，但通常用于执行一些包的初始化操作，例如导入子模块、定义包级别的变量、声明包级别的功能等。它可以包含其他模块引入包时需要执行的代码，并且在导入包的过程中被自动执行。

* `__all__ = []`是`__init__.py`文件中的一个可选变量。
  * 它定义了通过`from <package> import *`语句导入包时所导入的模块列表，即`*`只会导入`__all__`列表中指定的模块，默认情况下不会导入其他模块。
  * 使用`__all__`变量可以提供更明确的包接口，避免了不必要的导入，同时也提高了代码的可读性和维护性。
  
  



## 3. 常用特殊变量

### `__name__`

* 它是一个用于表示当前模块名或包名的特殊变量。
  * 当模块本地直接执行时，其值为`__main__`；
  * 当模块被导入时，其值为模块名。



### `__doc__`

* 用于保存模块、类、函数或方法的文档字符串（docstring）。



### `__file__`

* 指示模块的文件路径。对于动态创建的模块或内置模块，它可能没有对应的文件路径。



### `__all__`

* 仅在模块中存在，它是一个可选变量，用于指定从模块导入时应该导入的公共符号列表。



### `__init__`

* 用于初始化类的方法。在创建类的实例时自动调用。



### `__del__`

* 用于销毁类的实例时自动调用的方法。



### `__getitem__`

* 用于支持索引操作（`[]`），在自定义类中可以重写以提供自定义索引行为。



### `__setitem__`

* `__setitem__`: 用于支持索引赋值操作，在自定义类中可以重写以提供自定义的索引赋值行为。



### `__getattr__`

* 在访问不存在的属性时自动调用，可以用于提供动态属性访问的行为。



### `__call__`

* 使对象可以像函数一样被调用，在自定义类中实现该方法可以将类实例作为函数调用。



1. `__builtins__`: 包含 Python 解释器内置函数和异常的命名空间。
2. `__package__`: 用于表示当前模块所属的包名。若模块不属于任何包（即独立模块），则该变量值为`None`。
3. `__annotations__`: 用于存储变量和函数参数的类型注解。
4. `__dict__`: 对象的字典，包含对象的属性。可以通过`getattr()`和`setattr()`等函数访问。
5. `__class__`: 对象所属的类。在实例方法中，可以使用`self.__class__`引用当前类。
6. `__slots__`: 用于在类定义中指定实例可以具有的属性列表，以节省内存空间。
7. `__iter__`: 定义对象的迭代行为，使对象可以使用`for...in`循环进行迭代。
8. `__next__`: 定义迭代器对象的下一个元素的获取行为，通过`next()`函数调用。
9. `__len__`: 定义对象的长度（元素数量）获取行为，通过`len()`函数调用。
10. `__enter__`和`__exit__`: 用于支持上下文管理协议（Context Manager Protocol），实现资源的自动分配和释放。
